# FocusFlow MERN Stack Productivity App - Cursor Rules

## Project Context
This is a gamified productivity app called "FocusFlow" built with MERN stack featuring:
- Daily task management (max 3 tasks per day)
- Pomodoro timer with XP rewards (25 XP per completed session)
- Distraction tracking during work sessions
- Analytics dashboard with charts and progress tracking
- User authentication with JWT tokens
- Modern glassmorphism UI design

## Tech Stack Requirements
- Frontend: React 18 + Vite + Tailwind CSS + shadcn/ui
- Backend: Node.js + Express + MongoDB + Mongoose
- Authentication: JWT tokens with Context API
- Forms: react-hook-form with validation
- Charts: Recharts for analytics
- Icons: Lucide React
- Notifications: react-hot-toast
- State: Context API (Auth, Tasks, Timer, Theme)

## Code Style & Standards

### General Rules
- Use ES6+ features and modern JavaScript
- Prefer const over let, never use var
- Use descriptive, meaningful variable names
- Add JSDoc comments for complex functions
- Keep functions under 50 lines when possible
- Use async/await instead of Promise chains

### React Component Rules
- Always use functional components with hooks
- Use PascalCase for component names (TaskCard, PomodoroTimer)
- Keep components under 200 lines, split if larger
- Use named exports over default exports
- Implement proper prop validation
- Always include loading and error states
- Use custom hooks for reusable logic

### File Naming Conventions
- Components: PascalCase (TaskCard.jsx, UserProfile.jsx)
- Pages: PascalCase (Dashboard.jsx, Analytics.jsx)
- Hooks: camelCase with 'use' prefix (useAuth.js, useTimer.js)
- Utils: camelCase (formatDate.js, calculateXP.js)
- Constants: UPPER_SNAKE_CASE (API_ENDPOINTS.js)

### Import Order (Always maintain this order)
// 1. React imports
import React, { useState, useEffect } from 'react';

// 2. Third-party libraries
import { toast } from 'react-hot-toast';
import { format } from 'date-fns';

// 3. UI components (shadcn/ui)
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';

// 4. Local components
import TaskCard from '@/components/features/TaskCard';
import LoadingSpinner from '@/components/ui/LoadingSpinner';

// 5. Hooks and context
import { useAuth } from '@/hooks/useAuth';
import { useTaskboard } from '@/context/TaskboardContext';

// 6. Utils and constants
import { API_ENDPOINTS } from '@/utils/constants';
import { formatDate } from '@/utils/dateHelpers';

text

## Frontend Development Rules

### Component Structure Template
import React, { useState, useEffect } from 'react';
import { toast } from 'react-hot-toast';

const ComponentName = ({ prop1, prop2, ...props }) => {
// State hooks first
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);
const [data, setData] = useState(null);

// Context hooks
const { user } = useAuth();

// Effects
useEffect(() => {
// Effect logic with cleanup if needed
return () => {
// Cleanup
};
}, []);

// Event handlers
const handleAction = async () => {
setLoading(true);
setError(null);

text
try {
  // Implementation
  toast.success('Success message');
} catch (err) {
  const message = err.response?.data?.message || 'Something went wrong';
  setError(message);
  toast.error(message);
} finally {
  setLoading(false);
}
};

// Early returns for loading/error states
if (loading) return <LoadingSpinner />;
if (error) return <ErrorMessage message={error} onRetry={handleAction} />;

return (
<div className="bg-white/10 backdrop-blur-md rounded-xl p-6 border border-white/20 hover:bg-white/20 transition-all duration-300">
{/* Component JSX */}
</div>
);
};

export { ComponentName };

text

### Tailwind CSS Rules
- Always use Tailwind classes, never inline styles
- Follow mobile-first responsive design (sm:, md:, lg:, xl:)
- Use consistent spacing scale: 1, 2, 3, 4, 6, 8, 12, 16, 20, 24, 32, 48, 64
- Implement smooth transitions: transition-all duration-200, duration-300
- Use glassmorphism effects: bg-white/10 backdrop-blur-md

### Design System Colors
/* Primary Theme */
primary: #3B82F6 (blue-500)
secondary: #8B5CF6 (violet-500)
accent: #10B981 (emerald-500)
success: #22C55E (green-500)
warning: #F59E0B (amber-500)
error: #EF4444 (red-500)

/* Gradients */
primary-gradient: from-blue-500 to-blue-600
secondary-gradient: from-violet-500 to-purple-600
success-gradient: from-emerald-500 to-green-600

text

### State Management Patterns
// Context structure
const AuthContext = createContext({
user: null,
login: () => {},
logout: () => {},
loading: false
});

export const AuthProvider = ({ children }) => {
const [user, setUser] = useState(null);
const [loading, setLoading] = useState(true);

const value = useMemo(() => ({
user, setUser, loading,
login: handleLogin,
logout: handleLogout
}), [user, loading]);

return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

text

## Backend Development Rules

### API Endpoint Structure
// Route handler pattern
const routeHandler = async (req, res) => {
try {
// 1. Validate request
const { error } = validateSchema(req.body);
if (error) {
return res.status(400).json({
success: false,
message: error.details.message
});
}

text
// 2. Business logic
const result = await performOperation(req.body);

// 3. Success response
res.status(200).json({
  success: true,
  data: result,
  message: 'Operation completed successfully'
});
} catch (error) {
// 4. Error handling
console.error('Route error:', error);
res.status(500).json({
success: false,
message: error.message || 'Internal server error'
});
}
};

text

### MongoDB Schema Patterns
// Schema template with validation
const schemaName = new mongoose.Schema({
// Required fields
title: {
type: String,
required: [true, 'Title is required'],
trim: true,
maxLength: [100, 'Title cannot exceed 100 characters']
},

// User reference (always indexed)
userId: {
type: mongoose.Schema.Types.ObjectId,
ref: 'User',
required: true,
index: true
},

// Optional fields with defaults
completed: {
type: Boolean,
default: false
},

// Enum validation
priority: {
type: String,
enum: ['low', 'medium', 'high'],
default: 'medium'
}
}, {
timestamps: true, // Always include timestamps
toJSON: { virtuals: true },
toObject: { virtuals: true }
});

// Add indexes for performance
schemaName.index({ userId: 1, createdAt: -1 });
schemaName.index({ userId: 1, completed: 1 });

text

### Authentication Middleware
const authenticateToken = (req, res, next) => {
const authHeader = req.headers['authorization'];
const token = authHeader && authHeader.split(' ');

if (!token) {
return res.status(401).json({
success: false,
message: 'Access token required'
});
}

jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
if (err) {
return res.status(403).json({
success: false,
message: 'Invalid or expired token'
});
}
req.user = user;
next();
});
};

text

## FocusFlow Business Logic Rules

### Task Management
- Users can only have maximum 3 tasks per day
- Tasks are tied to specific dates (not just created date)
- Task completion should trigger XP rewards
- Implement optimistic updates for better UX

### Pomodoro Timer System
- Standard session: 25 minutes work, 5 minutes break
- Award 25 XP per completed session
- Track session start/end times
- Allow pause/resume functionality
- Store incomplete sessions for analytics

### XP and Level System
// XP calculation rules
const XP_REWARDS = {
COMPLETED_POMODORO: 25,
COMPLETED_TASK: 10,
DAILY_STREAK: 50,
WEEKLY_GOAL: 100
};

// Level calculation
const calculateLevel = (totalXP) => {
return Math.floor(totalXP / 100) + 1;
};

const getXPForNextLevel = (currentXP) => {
const currentLevel = calculateLevel(currentXP);
const nextLevelXP = currentLevel * 100;
return nextLevelXP - currentXP;
};

text

### Distraction Tracking
- Log distractions without stopping timer
- Quick distraction buttons: "Phone", "Social Media", "Thoughts", "Other"
- Track duration and frequency
- Minimal UI disruption during work sessions

## Error Handling Patterns

### Frontend Error Handling
// API error handler
const handleApiError = (error) => {
if (error.response?.status === 401) {
logout();
navigate('/login');
toast.error('Session expired. Please login again.');
} else if (error.response?.status === 403) {
toast.error('Access denied.');
} else if (error.response?.status >= 500) {
toast.error('Server error. Please try again later.');
} else {
toast.error(error.response?.data?.message || 'Something went wrong');
}
};

// Component error boundary
const ErrorBoundary = ({ children, fallback }) => {
const [hasError, setHasError] = useState(false);

useEffect(() => {
const handleError = () => setHasError(true);
window.addEventListener('error', handleError);
return () => window.removeEventListener('error', handleError);
}, []);

if (hasError) {
return fallback || <div>Something went wrong</div>;
}

return children;
};

text

### Backend Error Handling
// Global error handler
const errorHandler = (err, req, res, next) => {
let statusCode = err.statusCode || 500;
let message = err.message || 'Internal Server Error';

// Mongoose validation error
if (err.name === 'ValidationError') {
statusCode = 400;
message = Object.values(err.errors).map(e => e.message).join(', ');
}

// JWT errors
if (err.name === 'JsonWebTokenError') {
statusCode = 401;
message = 'Invalid token';
}

// MongoDB duplicate key error
if (err.code === 11000) {
statusCode = 400;
message = 'Resource already exists';
}

res.status(statusCode).json({
success: false,
message,
...(process.env.NODE_ENV === 'development' && { stack: err.stack })
});
};

text

## Performance Optimization Rules

### React Performance
- Use React.memo for components that receive complex props
- Use useMemo for expensive calculations
- Use useCallback for event handlers passed to children
- Implement lazy loading for routes and heavy components
- Debounce search inputs and API calls

### Backend Performance
- Add database indexes for frequently queried fields
- Use MongoDB aggregation pipelines for complex queries
- Implement pagination for large datasets
- Add response compression middleware
- Use caching for static or frequently accessed data

## Security Requirements

### Frontend Security
- Validate all user inputs before sending to API
- Sanitize data before displaying (prevent XSS)
- Use HTTPS in production
- Store JWT tokens securely (httpOnly cookies preferred)
- Implement proper CORS configuration

### Backend Security
// Security middleware setup
app.use(helmet()); // Security headers
app.use(cors({
origin: process.env.FRONTEND_URL,
credentials: true
}));
app.use(rateLimit({
windowMs: 15 * 60 * 1000, // 15 minutes
max: 100 // limit each IP to 100 requests per windowMs
}));

// Password hashing
const hashPassword = async (password) => {
return await bcrypt.hash(password, 12);
};

text

## Animation & UI Guidelines

### Micro-interactions
/* Loading states */
.loading-pulse {
@apply animate-pulse bg-gray-300 dark:bg-gray-700 rounded;
}

/* Hover effects */
.card-hover {
@apply hover:shadow-lg hover:scale-105 transition-all duration-200;
}

/* Button animations */
.btn-primary {
@apply bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 transform hover:scale-105 transition-all duration-200;
}

text

### Celebration Animations
- Task completion: Scale animation + checkmark
- XP gained: Number count-up with bounce
- Level up: Confetti effect + gradient text
- Streak milestone: Pulse animation with glow

## Testing Patterns

### Frontend Tests
- Test user interactions, not implementation details
- Mock API calls in tests
- Test error states and edge cases
- Use React Testing Library patterns

### Backend Tests
- Test API endpoints with different scenarios
- Test authentication middleware
- Test database operations
- Mock external services

## Common Patterns to Always Follow

### Loading States
{loading ? (

<div className="animate-pulse space-y-4"> <div className="h-4 bg-gray-300 rounded w-3/4"></div> <div className="h-4 bg-gray-300 rounded w-1/2"></div> </div> ) : ( // Actual content )} ```
Empty States
text
{items.length === 0 ? (
  <div className="text-center py-12">
    <Icon className="mx-auto h-12 w-12 text-gray-400" />
    <h3 className="mt-2 text-sm font-medium text-gray-900">No items found</h3>
    <p className="mt-1 text-sm text-gray-500">Get started by creating a new item.</p>
    <Button onClick={onCreate} className="mt-6">Add Item</Button>
  </div>
) : (
  // Items list
)}
Form Validation
text
// Always use react-hook-form with validation
const { register, handleSubmit, formState: { errors } } = useForm();

<input
  {...register("title", { 
    required: "Title is required",
    maxLength: { value: 100, message: "Title too long" }
  })}
  className={`form-input ${errors.title ? 'border-red-500' : ''}`}
/>
{errors.title && (
  <p className="text-red-500 text-sm mt-1">{errors.title.message}</p>
)}
Anti-patterns (Never Do These)
Don't use inline styles, always use Tailwind classes

Don't mutate state directly, use setState or reducers

Don't use var, always use const or let

Don't skip error handling for async operations

Don't create components over 200 lines

Don't use nested ternary operators (max 1 level)

Don't hardcode API URLs, use environment variables

Don't store sensitive data in localStorage

Don't skip loading states for async operations

Don't use any type in TypeScript (if applicable)

Don't forget cleanup in useEffect when needed

Don't skip validation on backend, even if frontend validates

Environment Variables
text
# Backend .env
MONGODB_URI=mongodb://localhost:27017/focusflow
JWT_SECRET=your_super_secret_jwt_key_here
JWT_EXPIRE=7d
NODE_ENV=development
PORT=5000
CORS_ORIGIN=http://localhost:5173

# Frontend .env
VITE_API_URL=http://localhost:5000/api
VITE_APP_NAME=FocusFlow
VITE_ENABLE_NOTIFICATIONS=true
